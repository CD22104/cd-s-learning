# 操作系统

## 什么是操作系统

对上，用户角度：操作系统是一个控制软件，管理应用程序，为应用程序提供服务，杀死应用程序

对下，内部管理：资源分配的分配器

操作系统起到承上启下的作用，硬件之上，应用程序之下

操作系统把CPU抽象成进程，磁盘抽象成文件，内存抽象成地址空间

- 软件
  - 应用软件
  - 系统软件
    - 功能软件
    - 操作系统，不属于特定的功能

操作系统层面的软件有两个不同的对外接口：

1. 面向应用程序，外壳shell

   - gui，图形化的表示方式，更好地向用户提供服务
   - 字符方式、命令行方式，unix常见，通过命令来完成功能

2. 面向内部，内核kernel（重点涉及）

   cpu调度器，物理内存管理，虚拟内存管理，文件系统管理，中断处理与设备驱动（直接与硬件相关）

操作系统的特征（OS kernel）

- 并发管理（并发：一段时间内多个程序运行；并行：一个时间点上，需要多个cpu）
- 共享，将资源分享给不同的程序（分时访问、互斥共享/同时访问）
- 虚拟：操作系统把CPU抽象成进程，磁盘抽象成文件，内存抽象成地址空间，让每个用户感到有一个计算机专门为他服务，物理机器虚拟成多台机器
- 异步：可以跑多个程序，下一个程序什么时候运行和停止，走走停停，时间不定，只要运行环境相同，运行的结果也要相同

## 为什么要学习操作系统

## 操作系统重要的基本概念~复习（10.19上课 ）

- 内核（操作系统）与外壳（命令解释程序）

- 寄存器、高缓（cpu与内存之间的差）与内存

- 多道程序设计

- 并发性、共享性、虚拟性（操作系统三大特征）

- 中断与陷阱

- 双重模式：用户态（目态）和内核态（管态）

  需要双重模式，不停转换

- 特权指令（仅在管态执行 ）与访管指令（只有用户态才有，访问管态的指令）

- 系统调用、API与库函数

  系统调用：操作系统给程序提供服务的接口，可以使用的最底层的唯一的接口，用户很少直接使用（不懂）

## 进程10.19

- 进程的概念

  执行中的程序，现代分时系统的工作单元。

  程序是静态的概念，进程是活动的，它本身的信息、在内存中的位置都不是固定的，进程会自己消失

  作业：批处理系统（早期）中正在运行的程序，现在也可以看成进程

  分时系统则称为用户程序或任务

  进程不只是程序的代码，还包括内存区域、当前指令（马上要执行）、堆栈段（用来放函数调用的入口即返回值，局部变量）、数据段（定义的全局变量，数组）、堆（动态分配的内存，用于用户在自己的程序中自己申请内存空间malloc--动态申请内存，备用）

- 进程的状态

  新建：进程正在创建中

  运行：指令正在被执行

  等待：进程被创建之后，有可能会不被运行，等待某时间出现，被占领，处理陷阱或处理io（如io完成或收到某个信号）

  就绪：可以被CPU运行，由于CPU正在为另一个进程服务，CPU没办法执行，CPU只能执行一个

  终止:   进程执行完毕（强制终止：kill）

  > ![image-20201019192935727](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20201019192935727.png)

- 进程的调度

  排队，每次选择就绪队列最前面的进程分配cpu，若排到了需要重新输入文件，则取得文件后进入队列最后。定时器中断：只能运行片段时间，如果被抢断，只能重新排队再处理。

  进程调度队列：有多个等待队列，根据等待的设备不同，进入不同的队列（作业队列，就绪队列（cpu调度程序来分配），设备队列）

  

- 进程控制块PCB——进程存在的唯一标记

  放进程的属性信息（大概一百多个），程序计数器：表示这个进程要执行滴滴下一条指令的地址。CPU寄存器：累加器，索引寄存器，堆栈指针，通用寄存器等等，每个pcb可以看做一个结构体

  属性举例：

  process state,process number(每次创建会改变),program counter,registers(知道执行到哪了),memory limits,list of open files... pionter

  进程之间切换，即更新pcb

  每个进程pcb占用很小，pcb



### 进程调度

**长期调度程序**（作业调度）:原则——维持系统稳定，合理搭配系统中cpu为主的进程和io为主的进程。有些进程放入磁盘的交换空间，使内存的空间扩大

i/o-bound process:在执行输入输出方面比执行计算话费更多时间。

cpu-bound process:很少产生io请求，更多计算

为维持系统稳定，使io为主和cpu为主差不多，合理搭配，移出部分使其达到要求

**短期调度程序**（cpu调度）：进程的某一部分被换出去

**中期调度程序**：不是都有



上下文切换



## 死锁

导致死锁的原因

1. 计算机系统中许多软硬件资源是独占性的
2. 死锁是因为多个进程竞争资源产生的，各占用了对方的资源，互相等待对方释放资源。

只有不可抢占的资源会导致死锁

每个资源都有一定数量的实例

进程只能按照申请，使用，释放的顺序使用资源

死锁的四个必要条件

1. 互斥，一次只能有一个进程使用该资源
2. 占有并等待，互相等待
3. 非抢占：资源不能被抢占，完成任务后才能释放
4. 循环等待：a等b，b等a

资源分配图

- 组成：结点和边集合
- 如果资源分配图没有环（包括箭头方向），则系统**一定**没有进程死锁，如果有环，则**可能**存在死锁

处理方法

1. 使用协议预防或避免（打破必要性的任何一个）

   **预防**

   - 不能通过互斥条件来预防死锁
   - 占有并等待
     - 全给
     - 全部给
   - 非抢占，适用范围有限，适合cpu寄存器和内存空间，不适用于其他资源
     - 已分配的资源可以抢占,按顺序给，直到给不了，后面也不给了
   - 循环等待：否定的方法是对所有的资源类型进行排序，要求每个进程按递增顺序来申请资源

   **避免**

   - 安全性检测算法
     - 如果安全，响应该请求
     - 如果否，不响应
     - 死锁避免需要预算
     - 也称银行家算法
       - ​	如何检测安全状态：找一个安全序列
       - 不安全的状态不一定会死锁

2. 允许进入死锁，检测，加以恢复（死锁）

3. 忽视死锁问题，认为死锁不可能发生（大多数操作系统采取这种措施），解决死锁的方法可能会导致性能的下降，且发生死锁的概率极低。

但在特殊系统中，死锁引发的损失可能会超过性能和可用性的损失  

![image-20201123202327386](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20201123202327386.png)